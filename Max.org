#+TITLE: Max Linke's Emacs configuration
#+OPTIONS: toc:4 h:4

* Personal Information
#+begin_src emacs-lisp
  (setq user-full-name "Max Linke"
        user-mail-address "max_linke@gmx.de")
#+end_src
* Installing packages
** Add package sources
Melpa is an alternative repository to the standard elpa repository. Melpa
contains a lot more packages then elpa and usually follows the development
status.
#+begin_src emacs-lisp
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.milkbox.net/packages/") t)
#+end_src
** Install missing packages
I use package.el to install a list of packages I like to have. The
implementation for this is currently not optimal because it will update the
package-content every time.

- TODO write a function that updates out-of-date packages
- TODO automate this list by writing it to a separate file every time I install
  a new plugin
#+begin_src emacs-lisp
    (package-initialize)

    (defun max/require-package (package)
      (setq-default highlight-tabs t)
      "Install given PACKAGE."
      (unless (package-installed-p package)
        (unless (assoc package package-archive-contents)
          (package-refresh-contents))
        (package-install package)))

    (defvar max/packages '(whitespace magit company
      yasnippet highlight-parentheses google-c-style
      fill-column-indicator monokai-theme color-theme-solarized elpy projectile
      auto-complete base16-theme))

    (dolist (p max/packages)
      (max/require-package p))
#+end_src
** diminish
#+begin_src emacs-lisp
  (max/require-package 'diminish)
  (require 'diminish)
#+end_src
* Backups
Emacs keeps a lot of backup files around. To keep them from polluting my normal
directories lets just collect them all in one place in case I really need them.
#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src
* Evil config
I've used vim for quite some time before changing to Emacs. During this time
I've grown quite fond of modal editing. Evil-mode is a near perfect vim
emulation in emacs and helps a lot in the transition.
#+begin_src emacs-lisp
  ;; install all evil packages that I use
  (max/require-package 'evil)
  (max/require-package 'evil-leader)
  (max/require-package 'evil-surround)
#+end_src
** Set before loading evil
This let's evil overwrite some emacs settings
- use evil-search (vim-like search) instead of isearch
- use C-w for windows key bindings
#+begin_src emacs-lisp
(setq evil-search-module 'evil-search
      evil-want-C-w-in-emacs-state t)
#+end_src
** Load and start evil mode
#+begin_src emacs-lisp
(require 'evil)
(evil-mode 1)
#+end_src
** general settings
#+begin_src emacs-lisp
  ;;dont move back one position after exiting insert mode
  (setq evil-move-cursor-back nil)
  (diminish 'undo-tree-mode)
#+end_src
** evil keymappings
#+begin_src emacs-lisp
  (define-key evil-normal-state-map "L" 'evil-end-of-line)
  (define-key evil-normal-state-map "H" 'evil-beginning-of-line)
  (define-key evil-normal-state-map (kbd "C-l")'evil-window-right)
  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
  ;; this uses evil-nerd-commenter
  ;;(define-key evil-normal-state-map "gc" 'evilnc-comment-or-uncomment-lines)
  (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
  (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
#+end_src
** Set mode indicator colors
Use some more colorful information about what mode I'm in. This changes the
color of the small icon showing the mode in the modeline buffer and the color of
the cursor itself. For the future it would be nice to change the color of the
whole mode-line depending on the mode, I have to test the powerline package for
emacs.
#+begin_src emacs-lisp
(setq evil-normal-state-tag   (propertize "N" 'face '((:background "green" :foreground "black")))
      evil-emacs-state-tag    (propertize "E" 'face '((:background "orange" :foreground "black")))
      evil-insert-state-tag   (propertize "I" 'face '((:background "red")))
      evil-motion-state-tag   (propertize "M" 'face '((:background "blue")))
      evil-visual-state-tag   (propertize "V" 'face '((:background "grey80" :foreground "black")))
      evil-operator-state-tag (propertize "O" 'face '((:background "purple")))
      ;; color cursor according to mode
      evil-emacs-state-cursor '("red" box)
      evil-normal-state-cursor '("green" box)
      evil-visual-state-cursor '("orange" box)
      evil-insert-state-cursor '("red" bar)
      evil-replace-state-cursor '("red" bar)
      evil-operator-state-cursor '("red" hollow))
#+end_src
** Evil-leader
A really nice plugin to emulate the vim leader key. This allows me to set my own
command layer that is guaranteed not to interfere with any standard key
bindings.

*** leader-config
#+begin_src emacs-lisp
  (require 'evil-leader)
  (setq evil-leader/in-all-states 1)
  (global-evil-leader-mode)
#+end_src
*** leader key bindings
#+begin_src emacs-lisp
  (evil-leader/set-leader "<SPC>")
  (evil-leader/set-key "l" 'evil-ex-nohighlight)
  (evil-leader/set-key "dw" 'whitespace-cleanup)
  (evil-leader/set-key "m" 'magit-status)
  (evil-leader/set-key "h" 'help)
  (evil-leader/set-key "ft" '(lambda ()
                               (interactive)
                               (find-tag (find-tag-default))))
#+end_src
** Evil-surround
#+begin_src emacs-lisp
  (require 'evil-surround)
  (global-evil-surround-mode 1)
#+end_src
* User Interface
** general settings
- Change "yes or no" to "y or n"
  #+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  #+end_src
- Use a more save scrolling behavior
  #+begin_src emacs-lisp
    (max/require-package 'smooth-scrolling)
    (require 'smooth-scrolling)
    (setq smooth-scroll-margin 5)
    (setq scroll-conservatively 9999
          scroll-preserve-screen-position t)
  #+end_src
- I like to use [[http://levien.com/type/myfonts/inconsolata.html][Inconsolata]] font
  #+begin_src emacs-lisp
  (set-default-font "Inconsolata-13")
  #+end_src
- Jump to the last cursor position after opening a file
  #+begin_src emacs-lisp
  (require 'saveplace)
  ;; use standard emacs folder
  (setq save-place-file (concat user-emacs-directory "saveplace.el") )
  (setq-default save-place t)
  #+end_src
- Use a visual bell
  #+begin_src emacs-lisp
    (setq-default visible-bell t)
  #+end_src
- use ibuffer to swtich between open buffers
  #+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  #+end_src
- wrap lines by default
  #+begin_src emacs-lisp
  (global-visual-line-mode)
  #+end_src
- wrap lines after 80 charaters and set fill-column to 80 as well.
  #+begin_src emacs-lisp
  (require 'fill-column-indicator)
  (setq fci-rulw-width 2)
  (setq fci-rule-column 80)
  (define-globalized-minor-mode
    global-fci-mode fci-mode (lambda () (fci-mode 1)))
  (global-fci-mode t)
  (setq-default fill-column 80)
  #+end_src
- no splash screen
#+begin_src emacs-lisp
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-message t)
#+end_src
- use <ESC> to quit command
#+begin_src emacs-lisp
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark  t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))
(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
(global-set-key [escape] 'evil-exit-emacs-state)
#+end_src
** TODO Colors
I like the Monokai color theme when I'm using the UI and fallback to solarized
in the terminal. Most of my terminals are set to solarized dark and it's 16
colors don't support the monokai theme.

TODO write a function to switch between monokai and solarized-light. The light
solarized theme is much better visible in bright light situations.
#+begin_src emacs-lisp
  ;(require 'base16)

  (defun terminal-color ()
    (setq base16-theme (getenv "BASE16_SCHEME"))
    (setq theme (concat "load-theme 'base16-" base16-theme))
    (eval theme ))

  (if window-system
      (load-theme 'monokai t)
    (terminal-color))
#+end_src
** Window decorations
Set the window size to 100 charatars. Disable tooltips and the menu-bar.
The menubar can contain useful tips and help discover new features in modes so
bind it to <F12> to show it again if I need it.
#+begin_src emacs-lisp
  (when window-system
      (tooltip-mode -1)
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (set-frame-size (selected-frame) 100 40))
  (defun max-menu ()
    (interactive)
    (menu-bar-mode))
  (global-set-key (kbd "<f12>") 'menu-bar-mode)
#+end_src
* Coding
** projectile
#+begin_src emacs-lisp
(projectile-global-mode)
(diminish 'projectile-mode)
#+end_src
** make coding in all languages better
- enable colorful highlighting of matching parentheses.
  #+begin_src emacs-lisp
  (require 'highlight-parentheses)
  (define-globalized-minor-mode global-highlight-parentheses-mode highlight-parentheses-mode
    (lambda nil (highlight-parentheses-mode t)))
  (global-highlight-parentheses-mode t)
  #+end_src

- auto close brackets and ident new lines
  #+begin_src emacs-lisp
  (electric-pair-mode 1)
  (electric-indent-mode 1)
  #+end_src

- Clean up whitespaces after save
  #+begin_src emacs-lisp
    (add-hook 'before-save-hook 'whitespace-cleanup)
  #+end_src

- show whitespaces by default
  #+begin_src emacs-lisp
    (global-whitespace-mode)
    (setq-default whitespace-style '(face tabs empty trailing lines-tail tab-mark))
  #+end_src

- set indentation
  #+begin_src emacs-lisp
    (setq-default indent-tabs-mode nil)
    (setq-default tab-width 4)
  #+end_src
** compiling things
compile when I hit F5, save all open buffers and scroll the output

#+begin_src emacs-lisp
  (global-set-key (kbd "<f5>") 'projectile-compile-project)
  (setq compilation-ask-about-save nil)
  (setq compilation-scroll-output 1)
#+end_src

close compilation buffer if there was no error

#+begin_src emacs-lisp
  (defun max/bury-compile-buffer-if-successful (buffer string)
    "Bury a compilation buffer if succeede without warnings "
    (if (and
         (string-match "compilation" (buffer-name buffer))
         (string-match "finished" string)
         (not
          (with-current-buffer buffer
            (search-forward "warning" nil t))))
        (run-with-timer .2 nil
                        (lambda (buf)
                          (bury-buffer buf)
                          (delete-window (get-buffer-window buf)))
                        buffer)))
  (add-hook 'compilation-finish-functions 'max/bury-compile-buffer-if-successful)
#+end_src

run compilation window in it's own window

#+begin_src emacs-lisp
  (defun max/close-compilation-buffer ()
    (when (not (get-buffer-window "*compilation*"))
      (save-selected-window
        (save-excursion
          (let* ((w (split-window-vertically))
                 (h (window-height w)))
            (select-window w)
            (switch-to-buffer "*compilation*")
            (shrink-window (- h 20)))))))
  (add-hook 'compilation-mode-hook 'max/close-compilation-buffer)
#+end_src
** language modes
- emacs-lisp
  use eldoc for emacs lisp files
  #+begin_src emacs-lisp
    (add-hook 'emacs-lisp-mode-hook '(lambda () (turn-on-eldoc-mode)
                                       (company-mode)))
  #+end_src

- C++
  use the [[https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml][google c++ style]] with 4 spaces instead of 2
  I perfer auto-complete for c-code it seems to work better
  #+begin_src emacs-lisp
    (require 'google-c-style)
    (defun max/cc-mode-hook ()
      (google-set-c-style)
      (google-make-newline-indent)
      (setq c-basic-offset 4))
    (add-hook 'c-mode-common-hook 'max/cc-mode-hook)
    (add-hook 'c++-mode-hook 'auto-complete-mode)

    ;;Autocomplete
    (require 'auto-complete-config)
    (add-to-list 'ac-dictionary-directories (expand-file-name
                 "~/.emacs.d/elpa/auto-complete-1.4.20110207/dict"))
    (setq ac-comphist-file (expand-file-name
                 "~/.emacs.d/ac-comphist.dat"))
    (ac-config-default)
  (diminish 'auto-complete-mode)
  #+end_src

- Python
  #+begin_src emacs-lisp
    (package-initialize)
    (elpy-enable)
  #+end_src

* snippets

#+begin_src emacs-lisp
(require 'yasnippet)
(yas-global-mode 1)
(diminish 'yas-minor-mode)
#+end_src

* Writing
** general settings
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src
** Latex
#+begin_src emacs-lisp
(setq TeX-auto-save t)
(setq-default TeX-master nil)
(add-hook 'LaTeX-mode-hook 'turn-on-flyspell)
;; open all tex files in LaTeX-mode
(add-to-list 'auto-mode-alist '("\\.tex$" . LaTeX-mode))
#+end_src
* Org Mode
Org-mode can be really slow with activated linnum mode.
Org-mode also does not show all headings with save-place
Electric indent mode also behaves weirdly for org

#+begin_src emacs-lisp
  (defun max/org-mode-hook ()
    (setq save-place nil)
    (flyspell-mode)
    (electric-indent-mode -1))
  (add-hook 'org-mode-hook 'max/org-mode-hook)

  (add-hook 'org-mode-hook 'turn-on-font-lock) ; not needed when global-font-lock-mode is on
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)

  (setq org-todo-keyword-faces
        '(("TODO" . org-warning) ("STARTED" . "yellow")
          ("CANCELED" . (:foreground "blue" :weight bold))))

  (custom-set-variables
   '(org-agenda-ndays 7)
   '(org-deadline-warning-days 14)
   '(org-agenda-show-all-dates t)
   '(org-agenda-skip-deadline-if-done t)
   '(org-agenda-skip-scheduled-if-done t)
   '(org-agenda-start-on-weekday nil)
   '(org-reverse-note-order t))

  (defun org ()
    (interactive)
    (find-file "~/org/organizer.org"))
#+end_src
** org-capture config
   Remember is a small tool to collect TODO notes during the day. Instead of the
   default "~/.notes" I want to keep my notes files in a folder with my agenda
   files
   #+begin_src emacs-lisp
     (defun notes ()
       (interactive)
       (find-file "~/org/notes.org"))
     (setq org-default-notes-file (concat org-directory "/notes.org"))
     (setq org-capture-templates
           '(("t" "Todo" entry (file+headline "" "Tasks")
              "* TODO %? \n %t\n %a")
             ("j" "Journal" entry (file+headline "" "Journal")
              "* %?\nEntered on %U\n %i\n %a")))
   #+end_src
** keyboard shortcuts
#+begin_src emacs-lisp
  (evil-leader/set-key "r" 'org-capture)
#+end_src
** Evil-org

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/plugins/evil-org-mode")
  (require 'evil-org)
  (diminish 'evil-org-mode)
#+end_src
* Convenience functions
   interactive function to open my config
#+begin_src emacs-lisp
  (defun max-edit-init ()
    (interactive)
    (find-file (expand-file-name "~/.emacs.d/Max.org")))
#+end_src
   reload my config
#+begin_src emacs-lisp
  (defun max-reload-init ()
    (interactive)
    (load-file (expand-file-name "~/.emacs.d/init.el")))
#+end_src
* mail
#+begin_src emacs-lisp
  (require 'notmuch)
#+end_src
